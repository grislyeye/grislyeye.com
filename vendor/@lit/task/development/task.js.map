{"version":3,"file":"task.js","sourceRoot":"","sources":["../src/task.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright 2017 Google LLC\n * SPDX-License-Identifier: BSD-3-Clause\n */\nimport {notEqual} from '@lit/reactive-element';\nimport {ReactiveControllerHost} from '@lit/reactive-element/reactive-controller.js';\n\nexport interface TaskFunctionOptions {\n  signal: AbortSignal;\n}\n\nexport type TaskFunction<D extends ReadonlyArray<unknown>, R = unknown> = (\n  args: D,\n  options: TaskFunctionOptions\n) => R | typeof initialState | Promise<R | typeof initialState>;\nexport type ArgsFunction<D extends ReadonlyArray<unknown>> = () => D;\n\n// `DepsFunction` is being maintained for BC with its previous name.\nexport {ArgsFunction as DepsFunction};\n\n/**\n * States for task status\n */\nexport const TaskStatus = {\n  INITIAL: 0,\n  PENDING: 1,\n  COMPLETE: 2,\n  ERROR: 3,\n} as const;\n\n/**\n * A special value that can be returned from task functions to reset the task\n * status to INITIAL.\n */\nexport const initialState = Symbol();\n\nexport type TaskStatus = (typeof TaskStatus)[keyof typeof TaskStatus];\n\nexport type StatusRenderer<R> = {\n  initial?: () => unknown;\n  pending?: () => unknown;\n  complete?: (value: R) => unknown;\n  error?: (error: unknown) => unknown;\n};\n\nexport interface TaskConfig<T extends ReadonlyArray<unknown>, R> {\n  task: TaskFunction<T, R>;\n  args?: ArgsFunction<T>;\n\n  /**\n   * Determines if the task is run automatically when arguments change after a\n   * host update. Default to `true`.\n   *\n   * If `true`, the task checks arguments during the host update (after\n   * `willUpdate()` and before `update()` in Lit) and runs if they change. For\n   * a task to see argument changes they must be done in `willUpdate()` or\n   * earlier. The host element can see task status changes caused by its own\n   * current update.\n   *\n   * If `'afterUpdate'`, the task checks arguments and runs _after_ the host\n   * update. This means that the task can see host changes done in update, such\n   * as rendered DOM. The host element can not see task status changes caused\n   * by its own update, so the task must trigger a second host update to make\n   * those changes renderable.\n   *\n   * Note: `'afterUpdate'` is unlikely to be SSR compatible in the future.\n   *\n   * If `false`, the task is not run automatically, and must be run with the\n   * {@linkcode run} method.\n   */\n  autoRun?: boolean | 'afterUpdate';\n\n  /**\n   * A function that determines if the current arg and previous args arrays are\n   * equal. If the argsEqual function returns true, the task will not auto-run.\n   *\n   * The default is {@linkcode shallowArrayEquals}. {@linkcode deepArrayEquals}\n   * is also available.\n   */\n  argsEqual?: (oldArgs: T, newArgs: T) => boolean;\n\n  /**\n   * If initialValue is provided, the task is initialized to the COMPLETE\n   * status and the value is set to initialData.\n   *\n   * Initial args should be coherent with the initialValue, since they are\n   * assumed to be the args that would produce that value. When autoRun is\n   * `true` the task will not auto-run again until the args change.\n   */\n  initialValue?: R;\n  onComplete?: (value: R) => unknown;\n  onError?: (error: unknown) => unknown;\n}\n\n// TODO(sorvell / justinfagnani): Some issues:\n// 1. With the task triggered in `update`, there is no ReactiveElement\n// change-in-update warning in the common case that the update itself does not change\n// the deps; however, Task's `requestUpdate` call to render pending state  will not\n// trigger another update since the element is updating. This `requestUpdate`\n// could be triggered in updated, but that results a change-in-update warning.\n// 2. There is no good signal for when the task has resolved and rendered other\n// than requestAnimationFrame. The user would need to store a promise for the\n// task and then wait for that and the element to update. (Update just justinfagnani:\n// Why isn't waiting taskComplete and updateComplete sufficient? This comment is\n// from before taskComplete existed!)\n\n/**\n * A controller that performs an asynchronous task (like a fetch) when its\n * host element updates.\n *\n * Task requests an update on the host element when the task starts and\n * completes so that the host can render the task status, value, and error as\n * the task runs.\n *\n * The task function must be supplied and can take a list of arguments. The\n * arguments are given to the Task as a function that returns a list of values,\n * which is run and checked for changes on every host update.\n *\n * The `value` property reports the completed value, and the `error` property\n * an error state if one occurs. The `status` property can be checked for\n * status and is of type `TaskStatus` which has states for initial, pending,\n * complete, and error.\n *\n * The `render` method accepts an object with optional methods corresponding\n * to the task statuses to easily render different templates for each task\n * status.\n *\n * The task is run automatically when its arguments change; however, this can\n * be customized by setting `autoRun` to false and calling `run` explicitly\n * to run the task.\n *\n * For a task to see state changes in the current update pass of the host\n * element, those changes must be made in `willUpdate()`. State changes in\n * `update()` or `updated()` will not be visible to the task until the next\n * update pass.\n *\n * @example\n *\n * ```ts\n * class MyElement extends LitElement {\n *   url = 'example.com/api';\n *   id = 0;\n *\n *   task = new Task(\n *     this,\n *     {\n *       task: async ([url, id]) => {\n *         const response = await fetch(`${this.url}?id=${this.id}`);\n *         if (!response.ok) {\n *           throw new Error(response.statusText);\n *         }\n *         return response.json();\n *       },\n *       args: () => [this.id, this.url],\n *     }\n *   );\n *\n *   render() {\n *     return this.task.render({\n *       pending: () => html`<p>Loading...</p>`,\n *       complete: (value) => html`<p>Result: ${value}</p>`\n *     });\n *   }\n * }\n * ```\n */\nexport class Task<\n  T extends ReadonlyArray<unknown> = ReadonlyArray<unknown>,\n  R = unknown\n> {\n  private _previousArgs?: T;\n  private _task: TaskFunction<T, R>;\n  private _argsFn?: ArgsFunction<T>;\n  private _argsEqual: (oldArgs: T, newArgs: T) => boolean;\n  private _callId = 0;\n  private _host: ReactiveControllerHost;\n  private _value?: R;\n  private _error?: unknown;\n  private _abortController?: AbortController;\n  private _onComplete?: (result: R) => unknown;\n  private _onError?: (error: unknown) => unknown;\n  status: TaskStatus = TaskStatus.INITIAL;\n\n  /**\n   * Determines if the task is run automatically when arguments change after a\n   * host update. Default to `true`.\n   *\n   * @see {@link TaskConfig.autoRun} for more information.\n   */\n  autoRun: boolean | 'afterUpdate';\n\n  /**\n   * A Promise that resolve when the current task run is complete.\n   *\n   * If a new task run is started while a previous run is pending, the Promise\n   * is kept and only resolved when the new run is completed.\n   */\n  get taskComplete(): Promise<R> {\n    // If a task run exists, return the cached promise. This is true in the case\n    // where the user has called taskComplete in pending or completed state\n    // before and has not started a new task run since.\n    if (this._taskComplete) {\n      return this._taskComplete;\n    }\n\n    // Generate an in-progress promise if the the status is pending and has been\n    // cleared by .run().\n    if (this.status === TaskStatus.PENDING) {\n      this._taskComplete = new Promise((res, rej) => {\n        this._resolveTaskComplete = res;\n        this._rejectTaskComplete = rej;\n      });\n      // If the status is error, return a rejected promise.\n    } else if (this.status === TaskStatus.ERROR) {\n      this._taskComplete = Promise.reject(this._error);\n      // Otherwise we are at a task run's completion or this is the first\n      // request and we are not in the middle of a task (i.e. INITIAL).\n    } else {\n      this._taskComplete = Promise.resolve(this._value!);\n    }\n\n    return this._taskComplete;\n  }\n\n  private _resolveTaskComplete?: (value: R) => void;\n  private _rejectTaskComplete?: (e: unknown) => void;\n  private _taskComplete?: Promise<R>;\n\n  constructor(\n    host: ReactiveControllerHost,\n    task: TaskFunction<T, R>,\n    args?: ArgsFunction<T>\n  );\n  constructor(host: ReactiveControllerHost, task: TaskConfig<T, R>);\n  constructor(\n    host: ReactiveControllerHost,\n    task: TaskFunction<T, R> | TaskConfig<T, R>,\n    args?: ArgsFunction<T>\n  ) {\n    (this._host = host).addController(this);\n    const taskConfig =\n      typeof task === 'object' ? task : ({task, args} as TaskConfig<T, R>);\n    this._task = taskConfig.task;\n    this._argsFn = taskConfig.args;\n    this._argsEqual = taskConfig.argsEqual ?? shallowArrayEquals;\n    this._onComplete = taskConfig.onComplete;\n    this._onError = taskConfig.onError;\n    this.autoRun = taskConfig.autoRun ?? true;\n    // Providing initialValue puts the task in COMPLETE state and stores the\n    // args immediately so it only runs when they change again.\n    if ('initialValue' in taskConfig) {\n      this._value = taskConfig.initialValue;\n      this.status = TaskStatus.COMPLETE;\n      this._previousArgs = this._getArgs?.();\n    }\n  }\n\n  hostUpdate() {\n    if (this.autoRun === true) {\n      this._performTask();\n    }\n  }\n\n  hostUpdated() {\n    if (this.autoRun === 'afterUpdate') {\n      this._performTask();\n    }\n  }\n\n  private _getArgs() {\n    if (this._argsFn === undefined) {\n      return undefined;\n    }\n    const args = this._argsFn();\n    if (!Array.isArray(args)) {\n      throw new Error('The args function must return an array');\n    }\n    return args;\n  }\n\n  /**\n   * Determines if the task should run when it's triggered because of a\n   * host update, and runs the task if it should.\n   *\n   * A task should run when its arguments change from the previous run, based on\n   * the args equality function.\n   *\n   * This method is side-effectful: it stores the new args as the previous args.\n   */\n  private async _performTask() {\n    const args = this._getArgs();\n    const prev = this._previousArgs;\n    this._previousArgs = args;\n    if (\n      args !== prev &&\n      args !== undefined &&\n      (prev === undefined || !this._argsEqual(prev, args))\n    ) {\n      await this.run(args);\n    }\n  }\n\n  /**\n   * Runs a task manually.\n   *\n   * This can be useful for running tasks in response to events as opposed to\n   * automatically running when host element state changes.\n   *\n   * @param args an optional set of arguments to use for this task run. If args\n   *     is not given, the args function is called to get the arguments for\n   *     this run.\n   */\n  async run(args?: T) {\n    args ??= this._getArgs();\n\n    // Remember the args for potential future automatic runs.\n    // TODO (justinfagnani): add test\n    this._previousArgs = args;\n\n    if (this.status === TaskStatus.PENDING) {\n      this._abortController?.abort();\n    } else {\n      // Clear the last complete task run in INITIAL because it may be a resolved\n      // promise. Also clear if COMPLETE or ERROR because the value returned by\n      // awaiting taskComplete may have changed since last run.\n      this._taskComplete = undefined;\n      this._resolveTaskComplete = undefined;\n      this._rejectTaskComplete = undefined;\n    }\n\n    this.status = TaskStatus.PENDING;\n    let result!: R | typeof initialState;\n    let error: unknown;\n\n    // Request an update to report pending state.\n    if (this.autoRun === 'afterUpdate') {\n      // Avoids a change-in-update warning\n      queueMicrotask(() => this._host.requestUpdate());\n    } else {\n      this._host.requestUpdate();\n    }\n\n    const key = ++this._callId;\n    this._abortController = new AbortController();\n    let errored = false;\n    try {\n      result = await this._task(args!, {signal: this._abortController.signal});\n    } catch (e) {\n      errored = true;\n      error = e;\n    }\n    // If this is the most recent task call, process this value.\n    if (this._callId === key) {\n      if (result === initialState) {\n        this.status = TaskStatus.INITIAL;\n      } else {\n        if (errored === false) {\n          try {\n            this._onComplete?.(result as R);\n          } catch {\n            // Ignore user errors from onComplete.\n          }\n          this.status = TaskStatus.COMPLETE;\n          this._resolveTaskComplete?.(result as R);\n        } else {\n          try {\n            this._onError?.(error);\n          } catch {\n            // Ignore user errors from onError.\n          }\n          this.status = TaskStatus.ERROR;\n          this._rejectTaskComplete?.(error);\n        }\n        this._value = result as R;\n        this._error = error;\n      }\n      // Request an update with the final value.\n      this._host.requestUpdate();\n    }\n  }\n\n  /**\n   * Aborts the currently pending task run by aborting the AbortSignal\n   * passed to the task function.\n   *\n   * Aborting a task does nothing if the task is not running: ie, in the\n   * complete, error, or initial states.\n   *\n   * Aborting a task does not automatically cancel the task function. The task\n   * function must be written to accept the AbortSignal and either forward it\n   * to other APIs like `fetch()`, or handle cancellation manually by using\n   * [`signal.throwIfAborted()`]{@link https://developer.mozilla.org/en-US/docs/Web/API/AbortSignal/throwIfAborted}\n   * or the\n   * [`abort`]{@link https://developer.mozilla.org/en-US/docs/Web/API/AbortSignal/abort_event}\n   * event.\n   *\n   * @param reason The reason for aborting. Passed to\n   *     `AbortController.abort()`.\n   */\n  abort(reason?: unknown) {\n    if (this.status === TaskStatus.PENDING) {\n      this._abortController?.abort(reason);\n    }\n  }\n\n  /**\n   * The result of the previous task run, if it resolved.\n   *\n   * Is `undefined` if the task has not run yet, or if the previous run errored.\n   */\n  get value() {\n    return this._value;\n  }\n\n  /**\n   * The error from the previous task run, if it rejected.\n   *\n   * Is `undefined` if the task has not run yet, or if the previous run\n   * completed successfully.\n   */\n  get error() {\n    return this._error;\n  }\n\n  render<T extends StatusRenderer<R>>(renderer: T) {\n    switch (this.status) {\n      case TaskStatus.INITIAL:\n        return renderer.initial?.() as MaybeReturnType<T['initial']>;\n      case TaskStatus.PENDING:\n        return renderer.pending?.() as MaybeReturnType<T['pending']>;\n      case TaskStatus.COMPLETE:\n        return renderer.complete?.(this.value!) as MaybeReturnType<\n          T['complete']\n        >;\n      case TaskStatus.ERROR:\n        return renderer.error?.(this.error) as MaybeReturnType<T['error']>;\n      default:\n        throw new Error(`Unexpected status: ${this.status}`);\n    }\n  }\n}\n\ntype MaybeReturnType<F> = F extends (...args: never[]) => infer R\n  ? R\n  : undefined;\n\nexport const shallowArrayEquals = <T extends ReadonlyArray<unknown>>(\n  oldArgs: T,\n  newArgs: T\n) =>\n  oldArgs === newArgs ||\n  (oldArgs.length === newArgs.length &&\n    oldArgs.every((v, i) => !notEqual(v, newArgs[i])));\n"]}