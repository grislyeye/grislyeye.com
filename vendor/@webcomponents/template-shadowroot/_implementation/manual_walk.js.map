{"version":3,"file":"manual_walk.js","sourceRoot":"","sources":["../src/_implementation/manual_walk.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright 2019 Google LLC\n * SPDX-License-Identifier: BSD-3-Clause\n */\n\nimport {hasNativeDeclarativeShadowRoots} from './feature_detect.js';\nimport {hasNoParentElement, isElement, isTemplate} from './util.js';\n\n/*\n * Traverses the DOM to find all <template> elements with a `shadowrootmode`\n * attribute and move their content into a ShadowRoot on their parent element.\n *\n * This processing is done bottom up so that when top-level <template>\n * elements are hydrated, their contents are already hydrated and in the\n * final correct structure of elements and shadow roots.\n */\nexport const hydrateShadowRoots = (root: ParentNode) => {\n  if (hasNativeDeclarativeShadowRoots()) {\n    return;  // nothing to do\n  }\n\n  // Approaches to try and benchmark:\n  //  - manual walk (current implementation)\n  //  - querySelectorAll\n  //  - TreeWalker\n\n  // Stack of nested templates that we're currently processing. Use to\n  // remember how to get from a <template>.content DocumentFragment back to\n  // its owner <template>\n  const templateStack: Array<HTMLTemplateElement> = [];\n\n  let currentNode: Element|DocumentFragment|null = root.firstElementChild;\n\n  // The outer loop traverses down, looking for <template shadowrootmode>\n  // elements. The inner loop traverses back up, hydrating them in a postorder\n  // traversal.\n  while (currentNode !== root && currentNode !== null) {\n    if (isTemplate(currentNode)) {\n      templateStack.push(currentNode);\n      currentNode = currentNode.content;\n    } else if (currentNode.firstElementChild !== null) {\n      // Traverse down\n      currentNode = currentNode.firstElementChild;\n    } else if (\n        isElement(currentNode) && currentNode.nextElementSibling !== null) {\n      // Element is empty, but has a next sibling. Traverse that.\n      currentNode = currentNode.nextElementSibling;\n    } else {\n      // Element is empty and the last child. Traverse to next aunt/grandaunt.\n\n      // Store templates we hydrate for one loop so that we can remove them\n      // *after* traversing to their successor.\n      let template: HTMLTemplateElement|undefined;\n\n      while (currentNode !== root && currentNode !== null) {\n        if (hasNoParentElement(currentNode)) {\n          // We must be at a <template>'s content fragment.\n          template = templateStack.pop()!;\n          const host = template.parentElement!;\n          const mode = template.getAttribute('shadowrootmode');\n          currentNode = template;\n          if (mode === 'open' || mode === 'closed') {\n            const delegatesFocus =\n                template.hasAttribute('shadowrootdelegatesfocus');\n            try {\n              const shadow = host.attachShadow({mode, delegatesFocus});\n              shadow.append(template.content);\n            } catch {\n              // there was already a shadow root.\n              // TODO(rictic): log an error event?\n            }\n          } else {\n            template = undefined;\n          }\n        } else {\n          const nextSibling: Element|null|undefined =\n              currentNode.nextElementSibling;\n          if (nextSibling != null) {\n            currentNode = nextSibling;\n            if (template !== undefined) {\n              template.parentElement!.removeChild(template);\n            }\n            break;\n          }\n          const nextAunt: Element|null|undefined =\n              currentNode.parentElement?.nextElementSibling;\n          if (nextAunt != null) {\n            currentNode = nextAunt;\n            if (template !== undefined) {\n              template.parentElement!.removeChild(template);\n            }\n            break;\n          }\n          currentNode = currentNode.parentElement;\n          if (template !== undefined) {\n            template.parentElement!.removeChild(template);\n            template = undefined;\n          }\n        }\n      }\n    }\n  }\n};\n"]}