{"version":3,"file":"template-shadowroot.min.js","sources":["src/_implementation/feature_detect.ts","src/_implementation/util.ts","src/_implementation/manual_walk.ts"],"sourcesContent":["/**\n * @license\n * Copyright 2020 Google LLC\n * SPDX-License-Identifier: BSD-3-Clause\n */\n\n// lib.dom.ts is out of date, so declare our own parseFromString here.\ninterface DOMParser {\n  parseFromString(string: string, type: DOMParserSupportedType, options?: {\n    includeShadowRoots: boolean;\n  }): Document;\n}\n\n// This isn't ideal. Setting .innerHTML is not compatible with some\n// TrustedTypes CSP policies. Discussion at:\n//     https://github.com/mfreed7/declarative-shadow-dom/issues/3\nlet hasNative: boolean|undefined;\nexport function hasNativeDeclarativeShadowRoots(): boolean {\n  if (hasNative === undefined) {\n    const html = `<div><template shadowrootmode=\"open\"></template></div>`;\n    const fragment = (new DOMParser() as DOMParser).parseFromString(html, 'text/html', {\n      includeShadowRoots: true\n    });\n    hasNative = !!fragment.querySelector('div')?.shadowRoot;\n  }\n  return hasNative;\n}\n","/**\n * @license\n * Copyright 2019 Google LLC\n * SPDX-License-Identifier: BSD-3-Clause\n */\n\nexport const hasNoParentElement =\n    (e: Element|DocumentFragment): e is DocumentFragment =>\n        e.parentElement === null;\nexport const isTemplate = (e: Node): e is HTMLTemplateElement =>\n    (e as Partial<Element>).tagName === 'TEMPLATE';\nexport const isElement = (e: Node): e is HTMLElement =>\n    e.nodeType === Node.ELEMENT_NODE;\n","/**\n * @license\n * Copyright 2019 Google LLC\n * SPDX-License-Identifier: BSD-3-Clause\n */\n\nimport {hasNativeDeclarativeShadowRoots} from './feature_detect.js';\nimport {hasNoParentElement, isElement, isTemplate} from './util.js';\n\n/*\n * Traverses the DOM to find all <template> elements with a `shadowrootmode`\n * attribute and move their content into a ShadowRoot on their parent element.\n *\n * This processing is done bottom up so that when top-level <template>\n * elements are hydrated, their contents are already hydrated and in the\n * final correct structure of elements and shadow roots.\n */\nexport const hydrateShadowRoots = (root: ParentNode) => {\n  if (hasNativeDeclarativeShadowRoots()) {\n    return;  // nothing to do\n  }\n\n  // Approaches to try and benchmark:\n  //  - manual walk (current implementation)\n  //  - querySelectorAll\n  //  - TreeWalker\n\n  // Stack of nested templates that we're currently processing. Use to\n  // remember how to get from a <template>.content DocumentFragment back to\n  // its owner <template>\n  const templateStack: Array<HTMLTemplateElement> = [];\n\n  let currentNode: Element|DocumentFragment|null = root.firstElementChild;\n\n  // The outer loop traverses down, looking for <template shadowrootmode>\n  // elements. The inner loop traverses back up, hydrating them in a postorder\n  // traversal.\n  while (currentNode !== root && currentNode !== null) {\n    if (isTemplate(currentNode)) {\n      templateStack.push(currentNode);\n      currentNode = currentNode.content;\n    } else if (currentNode.firstElementChild !== null) {\n      // Traverse down\n      currentNode = currentNode.firstElementChild;\n    } else if (\n        isElement(currentNode) && currentNode.nextElementSibling !== null) {\n      // Element is empty, but has a next sibling. Traverse that.\n      currentNode = currentNode.nextElementSibling;\n    } else {\n      // Element is empty and the last child. Traverse to next aunt/grandaunt.\n\n      // Store templates we hydrate for one loop so that we can remove them\n      // *after* traversing to their successor.\n      let template: HTMLTemplateElement|undefined;\n\n      while (currentNode !== root && currentNode !== null) {\n        if (hasNoParentElement(currentNode)) {\n          // We must be at a <template>'s content fragment.\n          template = templateStack.pop()!;\n          const host = template.parentElement!;\n          const mode = template.getAttribute('shadowrootmode');\n          currentNode = template;\n          if (mode === 'open' || mode === 'closed') {\n            const delegatesFocus =\n                template.hasAttribute('shadowrootdelegatesfocus');\n            try {\n              const shadow = host.attachShadow({mode, delegatesFocus});\n              shadow.append(template.content);\n            } catch {\n              // there was already a shadow root.\n              // TODO(rictic): log an error event?\n            }\n          } else {\n            template = undefined;\n          }\n        } else {\n          const nextSibling: Element|null|undefined =\n              currentNode.nextElementSibling;\n          if (nextSibling != null) {\n            currentNode = nextSibling;\n            if (template !== undefined) {\n              template.parentElement!.removeChild(template);\n            }\n            break;\n          }\n          const nextAunt: Element|null|undefined =\n              currentNode.parentElement?.nextElementSibling;\n          if (nextAunt != null) {\n            currentNode = nextAunt;\n            if (template !== undefined) {\n              template.parentElement!.removeChild(template);\n            }\n            break;\n          }\n          currentNode = currentNode.parentElement;\n          if (template !== undefined) {\n            template.parentElement!.removeChild(template);\n            template = undefined;\n          }\n        }\n      }\n    }\n  }\n};\n"],"names":["hasNative","hasNativeDeclarativeShadowRoots","undefined","html","fragment","DOMParser","parseFromString","includeShadowRoots","querySelector","_a","shadowRoot","hasNoParentElement","e","parentElement","isElement","nodeType","Node","ELEMENT_NODE","root","templateStack","currentNode","firstElementChild","tagName","push","content","nextElementSibling","template","pop","host","mode","getAttribute","delegatesFocus","hasAttribute","attachShadow","append","nextSibling","removeChild","nextAunt"],"mappings":";;;;;;AAgBA,IAAIA,WACYC,UACd,QAAkBC,IAAdF,EAAyB,CAC3B,MAAMG,EAAO,yDACPC,GAAY,IAAIC,WAA0BC,gBAAgBH,EAAM,YAAa,CACjFI,oBAAoB,IAEtBP,KAA6C,UAA/BI,EAASI,cAAc,cAAQ,IAAAC,OAAA,EAAAA,EAAAC,WAC9C,CACD,OAAOV,CACT;;;;;OCpBO,MAAMW,EACRC,GACuB,OAApBA,EAAEC,cAGGC,EAAaF,GACtBA,EAAEG,WAAaC,KAAKC;;;;;wECKWC,UACjC,GAAIjB,IACF,OAWF,MAAMkB,EAA4C,GAElD,IAAIC,EAA6CF,EAAKG,kBAKtD,KAAOD,IAAgBF,GAAwB,OAAhBE,GAC7B,GD5BoC,aC4BrBA,ED5BSE,QC6BtBH,EAAcI,KAAKH,GACnBA,EAAcA,EAAYI,aACrB,GAAsC,OAAlCJ,EAAYC,kBAErBD,EAAcA,EAAYC,uBACrB,GACHP,EAAUM,IAAmD,OAAnCA,EAAYK,mBAExCL,EAAcA,EAAYK,uBACrB,CAKL,IAAIC,EAEJ,KAAON,IAAgBF,GAAwB,OAAhBE,GAC7B,GAAIT,EAAmBS,GAAc,CAEnCM,EAAWP,EAAcQ,MACzB,MAAMC,EAAOF,EAASb,cAChBgB,EAAOH,EAASI,aAAa,kBAEnC,GADAV,EAAcM,EACD,SAATG,GAA4B,WAATA,EAAmB,CACxC,MAAME,EACFL,EAASM,aAAa,4BAC1B,IACiBJ,EAAKK,aAAa,CAACJ,OAAME,mBACjCG,OAAOR,EAASF,QAIxB,CAHC,MAGD,CACF,MACCE,OAAWxB,CAEd,KAAM,CACL,MAAMiC,EACFf,EAAYK,mBAChB,GAAmB,MAAfU,EAAqB,CACvBf,EAAce,OACGjC,IAAbwB,GACFA,EAASb,cAAeuB,YAAYV,GAEtC,KACD,CACD,MAAMW,EACuB,QAAzB5B,EAAAW,EAAYP,qBAAa,IAAAJ,OAAA,EAAAA,EAAEgB,mBAC/B,GAAgB,MAAZY,EAAkB,CACpBjB,EAAciB,OACGnC,IAAbwB,GACFA,EAASb,cAAeuB,YAAYV,GAEtC,KACD,CACDN,EAAcA,EAAYP,mBACTX,IAAbwB,IACFA,EAASb,cAAeuB,YAAYV,GACpCA,OAAWxB,EAEd,CAEJ,CACF"}